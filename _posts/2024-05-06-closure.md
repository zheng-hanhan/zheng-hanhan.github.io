---
title: Closure
date: 2024-05-06 22:57:34 +0300
categories: [programming_language, functional_programming]
tags: [closure]
---

## 1 Starting from a code snippet
```js
function outer() {
    let cnt = 0;
    function inner() {
        return ++cnt;
    };
    cnt = 2;
    return inner;
}
let inc = outer();
console.log(inc());
console.log(inc());
```
If we consider `inner` as a regular function, an error will occur during compilation.
Regular functions are only able to access local variables declared within their own lexical scope.
In the code snippet shown above, local variable `cnt` is declared and defined in `outer` function rather than `inner` function.

In programming languages such as Lua and JavaScript, function featuring this capability however is allowed.
The term **closure** is coined to describe such feature.
[Closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)) in wikipedia is as follows:

> a closure is a record storing a function together with an environment.The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the **value** or **reference** to which the name was bound when the closure was created.

For brevity, this article will refer to a closure using the same name as the function it stores.

Closure is an entity created dynamically at runtime. In this case, the `inner` closure contains the function `inner` and an environment which preserves the data associated with the variable `cnt`.

The `outer` function is commonly referred to as the **immediately enclosing/surrounding** function for the `inner` function.
`cnt` is often termed as **closed-over** or **captured** variable for the `inner` function.


Local variable typically cannot outlive the immediately enclosing scope. For instance, the variable `cnt` arises when it is declared and defined at line 2 and available to use until the closing curly at line 8. Local variables are typically allocated on the **stack**, leading to the commonly used term **stack memory** to describle the memory space reserved for them. The value of a local variable may be **primitive data types** and/or **references** to objects. And the value is typically stored on the stack. Once the `outer` function execution finishes, the **stack memory** where the `cnt`'s value is directly stored will be automatically reclaimed through the process of stack pointer adjustment.

So, a question arises: How does the `inner` closure at runtime still retain valid access to `cnt`?