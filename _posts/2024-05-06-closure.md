---
title: Closure
date: 2024-05-06 22:57:34 +0300
categories: [programming_language, functional_programming]
tags: [closure]
---

## 1 Starting from a code snippet
```js
function outer() {
    let cnt = 0;
    function inner() {
        return ++cnt;
    };
    cnt = 2;
    return inner;
}
let inc = outer();
console.log(inc());
console.log(inc());
```
If we consider `inner` as a regular function, an error will occur during compilation.
Regular functions are able to access local variables declared within their own lexical scope.
In the code snippet shown above, `cnt` is declared in `outer` function rather than `inner` function.

In modern programming languages such as Lua and JavaScript, code featuring this capability however is allowed.
These functions are commonly referred to as **closure**s.

[Closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)) is defined in wikipedia as follows:

> a closure is a record storing a function together with an environment.The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the **value** or **reference** to which the name was bound when the closure was created.

In this case, the closure contains the function `inner` and an environment which preserves the data associated with the variable `cnt`.
The `outer` function is commonly referred to as the **immediately enclosing/surrounding** function for the  `inner` function.
`cnt` is often termed as **closed-over** or **captured** variable.

Local variable typically cannot outlive the immediately enclosing scope. For instance, the variable `cnt` arises when it is declared and defined at line 2 and available to use until the closing curly at line 8.

Local variables are typically allocated on the **stack**, leading to the commonly used term **stack memory** to describle the memory space reserved for them.

Once the `outer` function execution finishes, the memory space where the `cnt`'s value is stored directly will be automatically reclaimed through the process of stack pointer adjustment.

<!-- markdownlint-capture -->
<!-- markdownlint-disable -->
> The value of a local variable may be **primitive data types** and/or **references** to objects. And they are typically stored on the stack. When a local variable reference an object which is dynamically allocated, the object itself is typically stored on the **heap**.
{: .prompt-tip }
<!-- markdownlint-restore -->


